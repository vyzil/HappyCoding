# 0005

집가면서 생각해보니 bruteforce 안해도
그냥 짠 코드 조금 수정하면 될 것 같음

수정할 방향은
반씩 sliding 해서 1을 찾음 -> 바로 이분탐색 들어감


case 1)
[o...o..]
o[...o...] -> l ~ (N/2+1)


case 2)
[.....]o..o
.[.....o]..o -> r+1 ~ N

두 케이스의 각 o가 있을 수 있는 범위 중, 큰 값을 기반으로 서치를 먼저 해야함

                if(r+1 <= N && ask(r+1, N) == 'O') {
                    result.l = r;
                    result.r = BinarySearch(N, r+1, N);
                }
                else {
                    result.l = l-1;
                    result.r = BinarySearch(N, l, N/2 + 1);
                }

                if(ask(r+1, N) == 'O') {
                    result.l = l-1;
                    result.r = BinarySearch(N, l, N/2 + 1);
                }
                else {
                    result.l = r;
                    result.r = BinarySearch(N, r+1, N);
                }

# 0004 solve

# 
첫 구간이 1일때가 엄청 많음
전부 O 인 경우,, (나가면서 들어오는 경우)
-> 이분탐색으로 변경하면 맞을듯

# 정리
47번 이하, 2개를 못찾는 상황에서 절반씩 나누는 방식은 일단 X

2 ~ 92 라고 했을 떄,
2 ~ (2+92)/2
부터
(2+92)/2 ~ 92
까지 해보면 됨

o x x x x o

o가 연속으로 나오다가 없어지는 구간


.[..o...].o...  O
..[.o....]o...  O
...[o....o]...  X   O 하다가 X 나오면 r
...o[....o.]..  O   X 하다가 O 나오면 l-1

1. 첫구간에 0개
- X하다가 O 나오면 r
- O 하다가 X 나오면 r

2. 첫구간 1개
- O 하다가 X 나오면 -> 1개가 나갔거나, 1개가 들어왔거나
+ 1 개가 나간 경우: O 하다가 X 나오면 l-1
+ 1 개가 나간 경우: X 하다가 O 나오면 r

+ 1 개가 들어간 경우 : O 하다가 X 나오면 r
+ 1 개가 들어간 경우 : X 하다가 O 나오면 l-1

+ 1 개가 나가면서 들어가는 경우 : O 하다가 X 나오면 r-1, r-1-range

3. 첫구간 2개
- X 하다가 O 나오면 l-1
- O 하다가 X 나오면 l-1

# 첫구간 X
X -> O , O -> X 때 기록,
(r, r) 또는 (l-1, l-1)

# 첫구간 O
O -> X, X -> O 때 기록
(l-1, r) 또는 (r, l-1)

안끝나는 경우, 홀 짝


# 다시 생각하기
2 ~ 97
0 -> 찾기
1 -> 1개 찾기

# 0002.c

# 0001.c -> 쿼리가 많잖아..
Flush
fflush(stdout)

흠..
결국 1개씩만 있을 떄 유의미한 서칭 가능

절반 절반씩 하다보면 
최악의 경우 92번 정도 까지도 가능 (마지막 두개이면)

즉 두개씩 서칭해야함

그러면 46 번

1 2
2 3
...
46 47

1. 두개 동시)
x x o o x x
X O X O X           O 가 두개       o

- 끝경우)
o o x x x
X O X X X           O 가 한개       o

x x x o o
X X X O X           O 가 한개       o




2. 두개 멀리
x o x o x x
O O O O X           O 가 4개

x o x x o x
O O X O O           O가 4개

끝경우)
o x x o x x
O x O O X           O가 3개     

x x x o x o
x x O O O           O가 3개

o x x x x o
O X X X O           O가 2개     o

AK소리 47번 이내
