# 우선순위 큐로 다시 구현해보자..

# ???
이걸 어떻게 통과했지?
다익스트라 구현을 이상하게함.
Queue로 구현해서 최소가 아닌 값을 꺼내올수도 있는데..
-> 내가 구현한건 우선순위 큐가 아니라서...

즉, 통과한 코드 (다익스트라 w. 큐)
다시 시도한 코드 (다익스트라) > 시간초과
효율적인 코드 (다익스트라 w. 우선순위 큐)


# 04 다익스트라?
Node 0에서 Node k 중 가장 긴 거리
Node k에서 가장 긴거리

# 03 그대로 수정
시간초과 원인 : 
실제로 모든 V에 대해서 할 필요가 없이 두번만 하면됨
임의의 한 Node 기준 
+ 그 노드로부터 젤 먼 Node 기준

# 03 >> 
visited 0으로 만드는거 생각해보니
2-> 3,4,5
이런식으로 3,4,5 하면 다시 3,4,5 넣고 진행함
결국 안끝남 -> 2로 진행하면 2를 뺴줘야할거같음
-> 2를 빼주면 안됨. 뺴면 BFS느낌으로 바뀜
-> DFS 유지,
2를 첫방문때는 visited가 0임.
두번쨰 방문에는 visited가 1 이므로
만약 방문시 이미 visited가 1이면 빼주고 continue

-> Still 시간초과



# 02 > 시간 초과 > 코드 오류 (visited를 0으로 만드는 부분이 빠짐)
트리
트리 Head[n] 
1 - 3
2 - 4
3 - 1 - 4
4 - 2 - 3 - 5
5 - 4



정점 : 100,000
arr로 하게되면 10,000,000,000 개의 int 필요 

# 01 >> 메모리 초과

간선 연결, 그래프 전부 입력 받고,
다익스트라? x
플로이드-워셜 알고리즘

0   1   2   3   4   5

1   0   x   x   x   x

2   x   0   x   x   x

3   x   x   0   x   x

4   x   x   x   0   x  

5   x   x   x   x   0   

#Q?
Input 순서대로??
5 로 시작하면
1 2 3 4 5대로?
1부터 시작?

          
                printf("arr[%d][%d] (%d) ? arr[%d][%d] (%d) + arr[%d][%d] (%d)\n", src+1, dst+1, arr[src][mid], src+1, mid+1, arr[src][mid], mid+1, dst+1,  arr[mid][dst]);
                getchar();