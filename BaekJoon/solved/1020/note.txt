# 
0 0 7
6+6+3
= 15

0 1 8
6 2 7

6가지 경우의 수

2 - 1
3 - 7
4 - 4
5 - 2 3 5
6 - 6 9 0
7 - 8


오른쪽부터 
x x x o 
o 같은 수 있는지 확인
없으면

x x o O
o O 같은 수 있는지 확인
O는 2 - 7

O가 증가하면 최소 4 최대 7



o가 n부터 가능할 때,
    
0   2 3 4 5 6 7
1   2 3 4 5 6 7
2     3 4 5 6 7 
3     3 4 5 6 7
4     3   5 6 7
5     3   5 6 7
6     3     6 7
7     3     6 7
8           6 7
9           6

2 - 7 
2 - 7 
2 - 7 
0 0 7
6 6 3
6 7~x
합 : 9

3 6 7 3
2 - 7 6

순서가 중요하네 
7~ 에서 6이 먼저 와야함


0   6 2 5 4 3 7
1   6 2 5 4 3 7
2   6   5 4 3 7
3   6   5 4 3 7  
4   6   5   3 7  
5   6   5   3 7    
6   6       3 7
7   6       3 7  
8   6         7
9   6          



[xxxxxxxxxxx] -> 조합이 가능하다는 결론


int DIGIT_COUNT[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 5};
--
[Count]
2 :1 
3 :7 
4 :4 
5 :2 3 5 9 
6 :0 6 
7 :8 

--
[Range]
0 :6 2 5 4 3 7 
1 :2 5 4 6 3 7 
2 :5 4 6 3 7 
3 :5 4 6 3 7 
4 :4 5 6 3 7 
5 :5 6 3 7 
6 :6 3 7 5 
7 :3 7 5 
8 :7 5 
9 :5 

0 0 7
matching = 8
x x o : 7 5
    3

matching = 3 + 6 = 9
left = 2
right = 7
x o O : 4~9
  1



      for(i = 0; i < 8; i++){
        printf("%d :", i);
        curNode = &global_countDigit[i];
        while(curNode->next) {
            printf("%d ", curNode->next->num);
            curNode = curNode->next;
        }
        printf("\n");
    }

    
    for(i = 0; i < 10; i++){
        printf("%d :", i);
        curNode = &global_countRange[i];
        while(curNode->next) {
            printf("%d ", curNode->next->num);
            curNode = curNode->next;
        }
        printf("\n");
    }



    0 0 7
    0 1 2

    6 5 4 3 7 1
    0 1 2 3 4 5

1000000000000000
1000000000000000