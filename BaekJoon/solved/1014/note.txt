# Feedback
타 풀이들 보면 수행속도가 0에 수렵함.

그리고 알고리즘 보면

- 다이나믹 프로그래밍
- 비트마스킹
- 최대 유량
- 비트필드를 이용한 다이나믹 프로그래밍

이렇다는데,
음.. 다는 일단 "bit field를 이용한 DP" 느낌인 것 같음
최대유량이랑 비트마스킹을 사용한건지는 모르겠음
비트마스킹은 맞는건가?

# 0001.c (sovle, 1116 KB 20 MS)
일단 보자마자 떠오르는게 별로 없는데, 생각좀해보자

대칭성에 대해서..
좌/우는 대칭이나
상/하는 대칭이 아님

휴리스틱처럼 될 것 같긴한데.. 
1. x가 없다고 가정하면?
줄무늬 형태로 배치, 가장 왼쪽을 채우거나 가장 오른쪽을 채워서 시작
결국 경우의 수는 꽤 많긴 하나, 최대 학생 수만 일단 구하면 되기 때문에
무조건 왼쪽 채운다고 가정

1-1. 열 갯수가 홀수 
두가지 경우 (왼쪽 오른쪽 끝 채우는 줄무늬)

1-2 열 갯수가 짝수

2개
1 0
0 1

4개 이상
1 0 1 0
0 1 0 1
1 0 0 1

1 0 1 0 1 0
1 0 1 0 0 1 
1 0 0 1 0 1
0 1 0 1 0 1

1 0 1 0 1 0 1 0
1 0 1 0 1 0 0 1
1 0 1 0 0 1 0 1
1 0 0 1 0 1 0 1
0 1 0 1 0 1 0 1

이런식으로 한칸씩 여유가 있네?

사실 규칙상으로 보면 2개를 나눌 피요도 없음
기본 한가지 (왼쪽부터 차곡차곡)
+ (n/2) 개의 오른쪽으로 한칸씩 넘기기 경우의 수

결론 : 만약 x 가 없다면 경우의 수
1. 열 갯수가 홀수 -> 차곡줄무늬
2. 열 갯수가 짝수 -> 차국 줄무늬 + 한칸씩 옮기기 경우

---
x가 있는 경우 고려)
위 경우의 수에서 x만 빼고 카운팅하면 되는 걸까?

1. 줄무늬가 정답이 아닌 경우가 있나?
아래처럼 줄무늬가 아닌 것을 강요하는 경우..
.x.x.x
.x.x.x
xxxxxx
x.x.x.
x.x.x.
x.x.x.

결국 2차원으로 DP를 만들긴 해야하는구만..
2차원으로 특정 위치에 학생이 있, 없 binary로 생각
그 데이터를 기반으로 배치, 배치x를 기록

아래부터 할까 위에부터 할까
배치학생 입장 -> A, D, E, C에 

근데 배치 x를 기록한다는 거는 지금까지 탐색 범위가 중요해짐
칸마다 배치 x가 필요힐까? -> 아닐수도

왼쪽 위에부터 해야 최대한 고려사항이 적음.
칸마다 배치 x가 필요하네

엥 아래부터 해야되네?
아래부터 하고, 배치된 학생 기준으로 카운팅을 해야할듯

배치/안배치

아래같은 상황에서 HOW?

DP xx ?? 
DP DP DP DP DP DP
DP DP DP DP DP DP
DP DP DP DP DP DP

[1] [x]
[2] [3] [4] 

x안배치는 [1][2][3][4]의 배치 안배치 중에서 최대?
x배치는 [2] 안배치 [4]안배치 [1] 안배치

* 배치 못하는 상황이면 (0/안배치)

=> 문제는 체크는 여러 공간을 봐야하는데, DP값은 여러 공간에 대한 DP값을 참조하기가 함듬

결국 내가 원하는 거는,
x에 배치할 때,

[안]  x
[안] [3] [안]
아래와 같은 상황에서의 값 + 1을 하고 싶은거

음.. 안배치를 생각할게 아니라, 이 상태 자체를 index로 만들 생각을 해야하나
비트DP인가? 그런 키워드를 봤던거 같은데, 여기서도 배치 or NOT 이니까 각각은 binary 상태라서
가능한가?
가로세로가 10*10이라 상태의 경우는 
2^100 -> 100 bit면 모든 state 표현 가능
그런데 DP값은... char사용해서 1 byte라고 해도 2^100개..?
두줄만 들고있을까? -> 두줄은 최대 1024*1024

비교할 위치 
1 
1 0 1

다음 비교할 위치는 shift 해서 쓰면 되긴 함

위에서부터 해도 되나

---
한줄별 상태에서 max
상태는 1024개가 최대
1024 스캔하면서 위에 10개 update

상태 -> bit 수

---



직전 하단 상태에서 max 값

다음 상태 : 직전 하단 상태에서 내가 가능한지 체크, 가능하면 거기에 +1해서 홀딩
최초 : 0만 1

자기 상태 : 연속된 1이 있으면 안됨

하단 상태와 현재 상태 비교
lshift, rshift 한걸 비교 and 1이 있으면 안됨

---
구현 과정에서, 위에서 하던 아래서 하던 대칭성이 있어서 상관 없음
대칭성이 있다는 말은,
맵을 좌우/상하 대칭해도 결과는 같은 것을 의미함.

---
두줄만 홀딩하기에는전부 한 줄이 전부 x인 경우가 있었음..
-> 이것도 0에 포함 되네? 그냥 오류가 있나봄
-> 코딩 실수, `strBuf[idx++] == 'x'`로 잘못 썻음
