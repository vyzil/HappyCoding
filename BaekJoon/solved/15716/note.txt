# 반례 정리

3 3
A 10
K K A
-> 39

2 3
A 6
K A
-> 8 (무한루프)

4 9
A 10
K K K A
-> (10) Wrong

3 4
A 6
K K A
-> (11) wrong

2 5
A 7
K A
-> (6) wrong



# 0004.c 
시간초과.. 50% 이상까진 가긴함

# 0003.c
Overflow 문제...
B의 범위가 10^12 라서, ACCUM 을 계산할 때 약간의 문제가 있다..
1. 128byte Data Type을 사용하기 -> Print문 구현
2. 



# 0003.c 
Integer Overflow를 해결해야함.
해결하고 DEBUG 지우고 제출하자.

printf("1\n");


# 0002.c 코드 깔끔하게 다시 -> 논리적인 문제는 대부분 해결한듯

LINE(i) : i째 줄, 단어 i번 나왔을 때 word의 수 : ((i)/N) * arr[N-1] + (i%N == 0 ? 0 : arr[((i)%N)-1])
ACCUM(i) : 

arr[i] = 한 주기에서 i까지 등장하는 word의 갯수
한 주기에서 워드의 갯수 = arr[N-1]

큰주기 (삼각형 주기)를 계산하기 
    + 삼각형 두개 + 가운데
    + 삼각형은 정확히 N에서 끊기지 않으니 처리를 조금 해줘야함.

큰주기로 대강 X번째 워드가 등장할 수 있는 범위 추리기

추린 범위에서 가운데를 기준으로,
가운데보다 작은지, 가운데인지, 가운데보다 큰지 파악
작거나 크면 대략적인 이분탐색을 통해 KN <= X < (K+1)N 의 k를 파악 << 등호 여부는 다시 생각해봐야함
k를 찾으면 이미 N에 누적합이 있기 때문에 N번 서칭하면 됨



*** B의 주기가 N이랑 딱 맞을 때, Increasing Phase에서 커버할 수 있는지 체크 필요



# 0001.c (포기, 코드가 너무 복잡해짐)

게임에 쓰일 단어의 수 n,
박자의 수 b

n <= b
같은 단어 여러번 가능

n, b (2개)
임의의 단어 K, X (2개)
n만큼의 단어 input (n개)

1 <= n <= 2 * 10^5;
n <= b <= 10 ^ 12;
1 <= X <= 10 ^12

---

산처럼 반복된다

한 주기 최대 
-> 2*b = 2*10^12 
=> 2,000,000,000,000 이건 전체를 구해놓지도 못하네..

음..

방법 1)
- 단어 K의 갯수를 어떤 형식으로든 카운팅해서 X 도달할 때 까지
- 특정 위치에서 해당 단어의 갯수를 계산하고 가까워지도록

--
일단, 한 주기에 몇개 있는지 수학적으로 계산, 
한 주기는 2b를 의미

주기를 넘는다? -> 일단 젤 가운데 기준으로 나누기? (약간 이분탐색 가능한가?)
-> 태그보니 이분탐색이긴 하다네.. (아직 모르겠음)

--
최악의 경우는 b가 10^12일 때..
arr[단어수] => 해당 idx 까지의 누적 갯수 합을 저장

단어의 위치를 idx로 저장
최대 10^5
0 x x x x ... -1


 N : o
     o o
     o o o
2N : x x x o
     x x x o o
     x x x o o o
3N : x x x x x x o 
     x x x x x x o o
     x x x x x x o o o

누적을 쉽게 계산할 수 있으면 이분탐색이 충분히 가능할듯
누적합은 o로 구성된 삼각형 열을 우선 계산한다 -> N만큼 필요
kN까지의 누적합은 {(k-1) 까지의 합} * 한 주기에서 갯수

// 이후 푸는 방법을 적어 놓을테니 나중에 풀기.

arr[i] = 한 주기에서 i까지 등장하는 word의 갯수
한 주기에서 워드의 갯수 = arr[N-1]

큰주기 (삼각형 주기)를 계산하기 
    + 삼각형 두개 + 가운데
    + 삼각형은 정확히 N에서 끊기지 않으니 처리를 조금 해줘야함.

큰주기로 대강 X번째 워드가 등장할 수 있는 범위 추리기

추린 범위에서 가운데를 기준으로,
가운데보다 작은지, 가운데인지, 가운데보다 큰지 파악
작거나 크면 대략적인 이분탐색을 통해 KN <= X < (K+1)N 의 k를 파악 << 등호 여부는 다시 생각해봐야함
k를 찾으면 이미 N에 누적합이 있기 때문에 N번 서칭하면 됨

최악의 경우 이분탐색이 제일 critical path 인 것 같음

unit = 한 주기
line = 한 줄
period = 한 이등변 삼각형
// arr[0] 에 대해서 조심, 한 period에 한번만 나옴

period의 시작
 1 : o
     o o
 N : o o o
N+1: x x x o
     x x x o o
2N : x x x o o o
2N1: x x x x x x o 
     x x x x x x o o
     x x x x x x o o o
     ..
 b : -----


 ---


i 라인의 워드 갯수
(i/N) * arr[N-1] + (i%N > 0 ? arr[(i%N) - 1] : 0);

iN line까지 워드 갯수
((i * (i- 1))/2) * N * arr[N-1] + i * inTri;


---




1 : king(1)
2 : king(2) god
3 : king(3) god gd
4 : king(4) god gd king(5)
5 : king(6) god gd king(7) god
6 : king(8) god gd king(9)
7 : king(0) god gd
8 : king(1) god
9 : king(2)
0 : king(3) god