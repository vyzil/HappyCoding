# Feedback
다른 답과 비교하면)
메모리는 얼추 비슷하고, 시간이 600MS대 까지는 많음

Parent Searching 부분 최적화 가능할듯


--
메모리는 DP 전체를 저장할 필요가 없이
Queue에만 저장하면 될 것 같음
그러면 최악의 경우에서만 DP와 똑같음



# 0001.c (solve, 83116 KB, 900 MS)
그리디 느낌으로 해볼까..?
갯수 많은 것 끊기?

문제를 잘못 이해함.
얼리어답터가 아닌 사람들은 자신의 모든 친구가 얼리어답터일 때만 아이디어를 받아드림

내가 NO면 -> 나머지가 Yes 여야함

Leaf부터 Yes, No 일때 그 아래까지 얼리어답터를 저장

//
자신으로 연결된 Node 가 없는 노드 기준 올라가야하는 데..
만약 입력이 정렬된 형태로 있다면 가능하고
그렇지 않다면 root 노드에서 탐색하면서 leafNode를 찾아야함.

DP 수식
자신의 Yes는 모든 자식의 (No/Yes) 중 최솟값의 총합
자신의 No 는 모든 자식의 YES 의 총합

일단 트리구조, root를 제외한 모두가 parent가 존재하므로 최소 1
따라서 연결된 간선이 1이면 root
근데 root는 parent가 없으니, root는 내가 그냥 정해서 +1 해주면 알아서 root 취급 될듯
왜냐하면 1인 친구들을 선택해서 DP를 업데이트 할 것이기 때문, root는 젤 마지막에 업데이트 된다.

---
입력 -> 인접리스트, 
인접리스트에는 연결된 노드의 수가 있어야함 (Queue에 넣을 수 있도록)
YES, NO DP가 있어야함.

// root 임의 설정해서 num을 1 증가
// num이 1인 애들 찾아서 queue에 넣음
// queue에서 한개씩 꺼내서 YES, NO 계산하고 자신과 연결된 parent 끊어서 num 감소
//  - 자식노드를 어떻게 알고 YES, NO 계산하지?
//      -> 탐사된 NODE의 num을 확인해서 0 또는 1이면 (implement dependent) 자식임을 알 수 있음
// root의 DP값 중 최솟값을 선택!

-> 자식이 parent DP를 업데이트 해줘야할듯
자신의 Yes는 모든 자식의 (No/Yes) 중 최솟값의 총합
자신의 No 는 모든 자식의 YES 의 총합
=>
부모의 YES 값에 자신의 (NO/YES) 중 최솟값을 더함
부모의 NO 값에 자신의 YES를 더함

// 자신의 YES는 default 1

---
parent 저장하거나, 간선 제거하면 좋겠는데


일단 정답은 나오는데, 
**Optimization Need 부분에서 시간복잡도가 O(n) 느낌이라
1. searching 중에 child 노드를 free 하기
2. parent 기록하기?
총 시간복잡도가 어차피
간선 * 2 라서 상관은 없을듯
