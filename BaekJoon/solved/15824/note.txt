# 0002.c
아마 sort를 함수구현으로 해서 좀 애매하고,
Merge Sort라서 합칠 때추가 메모리가 필요함
함수내의 local 변수들이 사실상 지속적으로 값을 홀딩해야하는
요소가 아니기 때문에 global로 두면 메모리는 조금 줄어들 것으로 예상
-> 수정해서 제출했는데, (4048KB, 124ms) 나옴


arr도 글로벌 변수로 두고 하긴 했는데,
애초에 log_2(N)만큼만 호출하니까 
arr, tmp, aIdx, bIdx, tIdx -> 5*4(byte) * 32 인 640Byte 정도만 이득볼 것 같고..
시간이 오히려 늘어나는 이유는 global parameter 참조하는데 시간이 오래걸리나..?
흠... locality관련이라기에도 차이가 거의 없을거같은데..

다시 코드 0001.c를 제출했는데 (4048KB, 116ms) 나왔음.
채점서버의 상황이나 채점데이터가 바뀌는듯..?

# 0001.c (solve: 4048KB, 112ms)
예시)
1 4 5 5 6 10
 3 1 0 1 4

2개 묶음
2^0       (3 + 1 + 0 + 1 + 4)
2^1 - 2^0 ((3+1) + (1+0) + (0+1) + (1+4))
2^2 - 2^1 ((3+1+0) + (1+0+1) + (0+1+4))
2^3 - 2^2 ((3+1+0+1) + (1+0+1+4))
2^4 - 2^3 ((3+1+0+1+4))

근데 이걸 세로로 묶으면
N에서 2개 뽑고, 그 사이에 있는 갯수
2개 뽑는게ㅜ N^2개..

SMALL이면
(3,000 * 2,999)/2 = 4,498,500
(300,000 * 299,999)/2 = 44,999,850,000

---
어차피 최솟값을 빼는거니까..

1 4 5 5 6 10
    x
예를 들어 x포함, x까지 고통지수 갯수 : 
1, 5    -> 1
4, 5    -> 4
1, 4, 5 -> 1
즉, 2^2-1개
포함, 포함x에서 전부 포함x 경우 빼기
5 * (2^2 -1)에서 아래 값 빼기
1 << 1 + 4


1 4 5 5 6 10
      x
1, 5        1
4, 5        4
5, 5        5
1, 2, 5     1
1, 5, 5     1
4, 5, 5     4
1, 4, 5, 5  1
2^3 - 1
5 * (2^3-1)
1 << 2 + 4 << 1 + 5

정렬을 무조건 해야 가능함

정렬하고 for 문 돌려서 찾는걸로

