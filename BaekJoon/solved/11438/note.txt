# Feedback
- 초기오류 
```diff
    while(u != v){
        for(cnt = 0; (1 << cnt) < uDepth ; cnt++){
            if(tree[u].ancestor[cnt] == tree[v].ancestor[cnt]) break;
        }
-       if(cnt > 2) cnt--; 
+       if(cnt > 1) cnt--;
        u = tree[u].ancestor[cnt];
        v = tree[v].ancestor[cnt];
        uDepth -= (1 << cnt);
    }
```
2가 넘치는 경우를 고려안하고, 2면 바로 뛰어도 괜찮네? 해버림(그냥 잘못 생각)

2로 matching 되면 바로 뛰어도 되는데, 2는 2^1 이라서 cnt가 1일때 가능했던겨..
"만약 uDepth보다 커서 for문을 탈출한 경우는 어떻게 하냐?" 라고 한다면,
2^0, 2^1 사이에는 skip한 수가 없기 때문에 for문을 탈출하면서 클 수는 없다 (트리가 정상적이라면)



# 0001.c
일단 트리다..
일단 부모노드의 번호만 저장하고 있으면 될 것 같은데

내가 기존에 최소공통조상 문제 푼 코드를 보니 최적화 없이 그냥 했던듯
임의의 한 점 잡고 트리로 쫙 만듬 (height 0 부터 해서)
그리고 각자 height에서 낮으면 올라감 그리고 비교함

일단 이런 구조를 추구하면 좋겠다 싶은 것:
균형잡힌 트리(?) -> 어떻게 서칭하냐에 따라 다를텐데, 기존에 내가 했던 방법대로면 의미는 없음

"트리"를 잘 생각해보면,
자식은 최대 두개임
자신 기준 아래의 서로다른 subtree의 원소들은 전부 최소공통조상이 자신.
왜 희소배열 태그지..?

시간복잡도만 생각해보자
M은 100,000 이므로 M^2은 안됨
MlogM까진 됨
MlogM만에 찾는 방법?
2^0조상
2^1조상
2^2조상
2^3조상 기록?
기록하는 게 N^2 일것 같은데..
아 기록하는게 NlogN이구나..

height 맞추는건 확실히 빠름 -> log(height 차이)
    + 원하는 height까지의 차이내에 가장 큰 2^k꼴의 k를 찾고, 그 k값을 index로 참조, 반복, height차가 없을때까지
같은 height 다를 때, LCA 까지 가는건? -> log(LCA 까지 거리)
    + 만들어놓은 array 참고해서 비교, 같은거 나오면 바로 직전까지 가기
    + 만약 2^0 또는 2^1 이면 바로 가고
    + 만약 그것보다 클떄 나오면 하나 직전

100,000 은 2^17범위 이내

---
// input
5
1 5
5 4
4 3
3 2
1
1 2

// ans
1
---
input
14
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
4 10
10 11
11 12
12 13
13 14
1
9 14

ans
4

---
input
3
3 1
3 2
3
1 2
1 3
2 3

ans
1
1
3
---