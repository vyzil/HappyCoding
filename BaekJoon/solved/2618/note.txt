#  이 문제 다시 풀어보기, 응용하기엔 완벽히 이해x, 최적화가 맘에 안듬



# 반례)
입력

1000

30

936 755

479 41

675 591

901 766

842 293

835 875

359 841

898 845

766 465

358 86

756 311

885 233

788 158

883 744

143 391

842 40

119 123

165 702

49 825

325 956

759 624

805 224

955 369

319 801

183 649

209 183

834 27

46 789

447 510

523 820

출력

12940

2

1

1

2

1

2

2

2

1

1

1

1

1

2

2

1

2

2

2

2

1

1

1

2

2

2

1

2

2

2

입력

1000
10
457 934
692 104
225 832
926 527
149 652
735 828
432 504
91 451
268 27
25 942

출력

5178
2
1
2
1
2
1
1
1
1
2




# 결과는 마지막줄 Scan하면 나옴
역추적만 짜면됨

(기록하면서 왔어야 했나..)


# 

       1   2   3   4   5   6   7   8
    x

1      x                                

2          x   ?   ? ->?

3               x       ?

4                  x   ?

5                       x

6                          x

7                               x

8                                  x




# Memoization 방식
DP[A][B]  
    - A : Car1이 해결한 마지막 사건
    - B : Car2가 해결한 마지막 사건 
    - 값 : 둘 중 큰 마지막 사건 기준으로 그때까지 최소 거리

# DP를 2개만 구해서 case 나누지 말고

- 지금 1이 solve 중 최소
    + 이전 1이 solve 중 최소 + 지금 1 solve
    + 이전 2가 solve 중 최소 + 지금 1 solve
- 지금 2가 solve 중 최소
    + 이전 1이 solve 중 최소 + 지금 2 solve
    + 이전 2가 solve 중 최소 + 지금 2 solve

DP 4개 다 가지고 있기
-> 이 방식은 DP가 계속 늘어나야함.
이런 방식 자체가 잘못됨

# 결국 같을때가 문제가 됐음..
5
4
2 4
4 2
3 3
5 5

answer:
10
1
1
1
2

output:
14
2
2
2
2


# 01

DP :    사건1 사건2 사건3 사건4
차1해결
차2해결

사건해결 순서도 출력해야하므로 그 데이터도 가지고 있어야함 
-> bit단위지만 일단 int형으로..


# 만약 누가하던 같으면...?
-> 위치정보는 달라지긴함. -> 다음 사건에 영향...
// 근데 같은데, 다른 모양새였을 가능성이 있나..?
-> 둘 다 해보는 걸로..