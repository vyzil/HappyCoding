# 생각 06
XOR?

0 = 000
S = 001
C = 010
S = 011
S = 100
AND 101


# 생각 05

S C S S C

S C S
S C

X 이렇게 하면 안됨
나머지 기준는 0부터 시작하고 이를 기준으로 주기는
C S C S S
0 1 2 3 4

+ 1

? C S C S S

%5

? C S C S
S

% 2

if( (((N % 5) + 1) % 5) % 2) printf("CY\n");

별로..



# 생각 04
1턴전 -> 주기를 2로 만듬
4턴전 -> 주기가 2인데, 4주기를 xor함(SK입장에서 선택권이 많아짐)

101010101010
1001 을 XOR

1 0 1 0  
1     1>1
  1     1>1
    1     1>0

16추가돼서
1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 

S C S S C
1001만 했을때
16 번쨰 추가했을 때 어그러지는 경우 -> SK SK 만 나왔는데 16전이 CY인 경우..

  S C S S C 중 각 부분의 15전은 동일 그럼 그것보다 한개 더 전
  C S C S S C -> 즉 윗 부분의 C일 때 아래는 계속 S가 나옴

  16은 나머지가 1
  64는 그럼? -> 64는 5로 나눴을 때 나머지가 4
  S C S S C
S C S S C S : 마찬가지로, 윗 부분이 C일 때 아래는 계속 S가 나옴 

즉 위에서 4^k는 5로 나눴을 때 1 또는 4가 남는데,
두 경우 모두 주기를 바꾸지 않음
  
다시, 1 > 4가 추가될 때를 생각해보면

 S C -> 주기가 2, 4는 2로 나눴을 때 나머지가 없음 ( 경우의 수 1개 )
 S C -> 윗 부분이 C 일 때 S가 나오는 부분이 있음 -> 즉 주기가 바뀜



# 생각 03
16 전까지는
1칸전, 4칸전만 보고 CY가 이기는 경우가 있으면 SK가 이김
없으면 CY가 이김

3 전까지는
1칸전만 보고 CY가 이기면 SK가 이김

즉
1만 가능 -> 주기가 2
4도 가능 -> 주기가 5 
16  가능 -> 주기가 17?
-> 16칸 전 
: 4칸전


SK CY SK SK CY 의 주기가 16에 영향을 안미침?



# 생각 02
내가 계산할 필요 없이, 
만약, 무조건 이기는 방향으로 플레이하는 프로그램이 있다?
-> 그 프로그램이 판도를 바꾸면 나도 바꿈 이런식으로함
즉, 서로 계속 판도를 바꾸면서 진행할 것임.


1만 -> 홀수면 SK
1       SK
2       CY
3       SK
4       CY

1, (4 1번) 만
4       SK
5       CY
6       SK
7       CY
8       SK

1, (4 2번 가능) 만
8       SK는 1 => 1/1/1/1/1/1/1/1/1/ -> CY                  
        SK는 4 => 4/4 -> CY
9       홀수면 SK가 이기니까, 
10
11

# 생각 01
돌을 4^k 가져갈 수 있다..?

SK 먼저 시작, 마지막 가져가면 이김



- 1개만 가져갈 수 있다.

1개 -> SK
2개 -> CY
3개 -> SK
4개 -> CY


- 1개 또는 4개 가져갈 수 있다

4개 -> SK
5개 -> CY
6개 -> SK
7개 -> CY

4 + 1 + 1 + 1 + 1

4개를 1개씩 가져가면 지는 경우를
한번에 가져가면 이김

즉 4로 묶으면 판도가 바뀜
그러면 4로 가져갈걸 16으로 가져가면 판도가 바뀜

무슨 말이냐, 
1의 갯수가 판도를 정하는데
4를 한번 하면 판도 업기
16을 한번하면 판도 그대로
이런 의미
그러면 64는? 판도 업기

즉, 4^k 에서 k가 홀수이면 판도 업기
나머지는 1의 갯수가 결정
(1, 3 = SK, 2 = CY)


|XX|XX|XX|XX(4의 갯수)|XX(1의 갯수)
2-bit 단위로 해석




