#
그러나, 0001.c 는 느리고 메모리도 많이 잡아먹는다..
C++로 작성한 사람들 보면 48ms 정도? 그리고 4000KB 정도로 푼 사람도 있다

일단 가능할 것 같은 최적화 방법은.. 
다른 알고리즘을 써야하나? 효율적으로 작성한 것 같은데..

-> 알고리즘 분류를 보니 분리집합 이라는데,
-> C++에서는 Set이라는 걸 사용하기도 했다는데, 이게 뭐지..
    + 원소관리를 O(logN)에 걸쳐서 수행?
    + 색칠한 칸의 index를 Set에서 erase?
    + 그러면, 최대 N개를 찾고 색칠하니까 NlogN 이다?    
    -> C로 어떻게 구현해야하지...?


# 0001.c > 통과 (10060KB, 112ms)
    6 2

    1 2 3 4 5 6
          1         3
    2       2       1

가면서 scan,
    2 2 2 1 2 0
    1 1 1 3 1 0

- 위 예시처럼 시작과 끝이 같다면, -> end는 +1 해서?
- 만약 같은 자리에 색칠이 있다면 -> Linked로 해결 가능한가?

    1 2 3 4 5 6
    1   1           3
    2     2         1

1. 
2가 check 되어 있는지 확인 -> x -> check 하고 min 값을 2로
1이 check 되어 있는지 확인 -> x -> check 하고 min 값을 1로
현재 min값의 색깔을 출력

2. 
연결된거 없음
현재 min값의 색깔을 출력

3. 
1이 check 되어 있는지 확인 -> O -> check 하고 min 값을 update to 2
+ min 값 update는 어떻게...? 앞에서부터 scan 하면
+ O(nlogn)으로 min Heap 구현? -> 가능할듯 -> 이분탐색 해야할거같은데..
+ min Heap은 중간 component를 뺼 수가 없음..
+++++ 여기가 문제, nlogn 이 안되는 거 같음..
+ min Heap 하고, checkList 확인해서 빼야할듯,
+ 다음 최솟값 찾을 때, 한번만 빼는게 아니라, 뺸 후에도 check 해제되어 있으면 또 뺴고 반복
+ 어차피 Heap에 들어간 요소는 최대 N이라서 뺴기는 반복해도 됨
log_2(100000) = 16.6096404744

현재 min 값의 색깔을 출력

4. 
괜찮은데?

---
N에 대한 Linked List 필요, end를 +1 해서 쓸 예정이라 N+1까지 malloc
check 되어 있는지 확인하는 list 필요, Query 수 만큼
Query에 대한 색깔을 담는 list 필요

1 ~ N 까지네..
range[i].num 은 연결된 노드 수,
range[i].next 부터는 num 이 start or end+1

end + 1 까지 malloc 할 필요 없이, 그냥 end + 1이면 연결 안해도 될듯? 그냥 종료시키면 ㅇㅇ


/*
 *  Linked List[N] saving Query num
 *  1 -> 2
 *  2
 *  3
 *  4 -> 1
 *  5 -> 1
 *  6 -> 2
 *  
 * Query[Q] saving color
 * 0 1
 * 3 1
 * 
 * Scan Linked List : 1 ~ N, Query in Min Heap
 * 
 */
