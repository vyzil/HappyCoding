# 다른사람
다른사람은 벽 갯수만큼 Map을 만듦 -> map[n][m][w]
Queue에 넣을 때, 뚫은 wall의 갯수도 저장하고
wall에 갯수에 따라 다른 map을 사용해서 bfs 한 느낌

# 다른 방법 생각해보기
0을 한 뭉치로 생각 -> N,N을 포함한 뭉치끼리 연결?

BFS로 일단 길 뚫어 놓고, 숫자 증가하는 쪽으로만 체크해놓음.

만약 벽의 상하좌우 비교했을때 숫자 차이가 크면 체크

만약 벽때문에 못간다?

N,N에서 역으로 경로탐색?
-> 벽 기준으로 상하좌우 탐색 해서 [다른 분단] 이면 더하고 최솟값

그냥 Map 두개 만들고 
1,1 출발 경로에 메모
N,N 출발 경로에 메모

모든 벽 기준으로 상하좌우, 같은곳에 숫자 있는건 의미 x
    상             상
  좌[1]우        좌[2]우
    하             하

[1]좌 <-> [2] : 상우하
합값이 최솟값보다 작으면 최솟값 업데이트


# 직관적인 방법
1. Map 저장 -> 벽은 -1로 저장하는게 좋을 듯
2. Map 복사 후 1 하나씩 0으로 바꾸고
    + 1과정에서 Map 한개씩 탐색하면서
3. BFS 방식으로 Scan (0에 거리 저장하면서)
4. (N,N)의 숫자가 최단거리
5. 2로 Loop; 1 갯수만큼 반복

* 벽은 1보다는 -1? (BFS 하면서 음수면 벽, 양수면 지나간 칸 or 안간곳)
* 벽을 MAX 값으로 하면 자기보다 크면 바꿔라 하면 될 것 같은데

===============
for(i = 0; i < iN; i++){
        for(j = 0; j < iM; j++) printf("%8d ", forwardMap[i][j]);
        printf("\n");
    }
     for(i = 0; i < iN; i++){
        for(j = 0; j < iM; j++) printf("%8d ", reverseMap[i][j]);
        printf("\n");
    }