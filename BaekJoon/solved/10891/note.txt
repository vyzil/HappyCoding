# Feedback
일단 타잔 알고리즘을 생각하면서 코딩함.
DFS 방식으로 child의 Root 들과 자신의 Root 중 작은 값으로 업데이트 하는 방식인데,
Child가 최초의 자신의 root 와 같거나 작은 값을 반환하면 update 값을 1 증가함
update 값이 2번 이상 발생하면 자신으로 돌아올 수 있는 두가지 경로가 있다는 뜻이므로
그런 경우 not cactus를 출력했음

참고로 SCC를 뽑는게 아니라서 Stack을 사용해서 넣고, 같은 SCC인거 뺼 필요가 없음.

일단 확실한 것은, 타잔 알고리즘이 너무 헷갈림
입력받을 때의 정점 번호가 부여한 번호랑 달라서 너무 헷갈림.

그리고 DFS가 끝날 때, Stack에서 빠지는 구조라
함수 수행중에 Stack 상태가 잘 예상, 생각이 안됨

1.
adjList[정점 번호] = 부여한 번호
root[부여한 번호] = root

2.
adjList[정점 번호] = root
index[정점번호] = 부여한 번호

위와 같은 array를 만들어서 사용해야하나? (1번이 덜 헷갈릴 것 같긴함)

---
그리고 양방향 그래프에서 한번 사용한 간선은 다시 사용 못하게 해야하는데, 그게 좀 거슬렸음.
1. DFS 하자마자 previous에서 온 간선을 끊는 방법 : adjList라 그냥 직관적으로 시간복잡도가 크게 올라갈 것 같았음 (정확히는 계산 안해봄)
2. 많은 부분에서 이를 고려한 로직을 삽입 : 이 방법으로 했는데 좀 구질구질한 코드가 나온 것 같음
    + dfs에서 prev를 같이 전달해서 지나온 간선을 통해서는 dfs는 안되도록 설정
    + dfs 하다가 작은 번호를 만났을 떄, 자신의 root를 작은 번호로 update 하는데
    그 작은 번호에서도 추후에 자신을 참조할 것임. 해당 참조에서 update 값이 하나 증가하는데,
    이는 유효한 로직이 아님. (이미 해당 간선을 통해 update 했었으므로)

더 좋은 방법은 뭐가 있었을까..
머리아파.. 나중에 생각..

# 0001.c (solve, 16024 KB 56 MS)
Cactus > SCC 구하기

SCC 구하는 과정에서 
stack에 쌓으면서 진행되고,
- 자기보다 낮은 숫자 만나면 Stack에 넣지 않고 자기 root랑 최솟값 비교함
- 숫자 없으면 자기숫자 + 1을 부여하고 그 경로를 실행, 그 경로의 반환값과 자기 root 최솟값을 비교해서 작은걸로 update

만약 자기에서 다음 경로가 없으면 pop 하는데,
return하면서 root값을 전달함

root 비교할 떄, 
자기 자신과 비교하는게 아니라, 다른값과 비교한다? -> Cycle이 최소 두개가 있다는 의미


근데 SCC는 단방향인데 여기는 양방향이네?
-> 양방향을 단방향 두개로 해석한담에 숫자 1큰걸로는 경로탐색 안하는걸로?


a -> b 로 갔었으면 b -> a로 안가게 해야하는데.. 그러면 parent를 기록?



--- 
타잔 알고리즘 돌껀데,
만약 root update가 두번된다?
DFS 호출하면 prev를 같이 호출하는데, 
stack에 넣고 DFS 한다고 하면 curNode searching 하면서 아예 간선 없애기

--- 
그냥 타잔 알고리즘인데, child 중 자기 자신과 같거나 작은값을 2번이상 return 하면 cactus가 아닌듯

--
update 횟수로 판단하는게 맞을듯..
여기서 udpate는 update된 횟수가 아니라, 유효한 시도 횟수를 말하며
유효한 시도 횟수는 자신과 같거나 작은 값으로의 udpate 시도를 말함

양방향 간선을 단방향화 하는게 좀 힘든데..
일단 prev를 기록해서 이전 간선으로부터는 자신을 update 하지 않도록 설정하고
check 역할을 하는 adjList[i]도 활용

update 횟수는 그럼..