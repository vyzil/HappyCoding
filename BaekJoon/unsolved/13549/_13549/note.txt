# 
(곱하기하면 넘치는 상황에서)
빼기 > 곱하기로 맞추기 > 더하기 빼기
더하기로 맞추기
곱하기 > 빼기로 맞추기

결국 더하기나 빼기는 한번 하면 특정 숫자를 원해서 하는건데
그 특정 숫자는 패턴일 가능성이 높음




# 
bit를 활용하면 좋을 것 같은데..

시각적)
타겟하는 bit : 1110000010101
현재위치 bit : 1110
-> shift하고 1 씩 추가하면 된다

# 
근데 문제는

111111111111111111
1
같은 경우에는 shift하고 1을 빼는 방향으로 가능


참고로, shift하면 0이 나오는 걸 의식하면 좋을듯

1이 연속으로 나온다면
1 더하면서 shift 하는 것 보다는
shift하고 1을 뺴는 방향이 이득임

1이 두개라도 좋음 ( 확인해보니 두개는 똑같고 세개부터 좋을듯 )
xxx011
xxx[]
-> 1 더하기, shift 2번, 1빼기


# 
참고, 크면 그냥 빼는거 밖에 답이 없음


# 
위의 패턴이 맞을 때는 쉬움
근데 초기 패턴이 안맞는 상황이 좀 쉽지 않을듯

ex)
## 01
111111100010
100001010100

1. shift하면 넘는 상황 
- shift하고 빼기
- 그냥 빼기
큰걸루

## 02
111111100010
    10000101

1. 비트 맞추기
111111100010
    10000101
    11111110 | 0010

위에를 어떻게 맞출지
-> 위에 맞추는거 아까 1번에서 한거잖아?

bit 수 동일하다는 가정)
내 논리는 크면 마이너스계속 한다는 건데.. 이럴 떄 안좋을 수 있다
ex)
1000000000000xxxx
1111111111111
-> 이런 경우

상위 bit를 맞춘 다는건, 최상위 bit부터 진행해야 한다.
즉,
10
11
여기서부터 진행해야함
-> (---wrong 01) 에서 해봤는데 안됨

# 
그러면 다시, 정해진 숫자를 어떻게 할것인가를 고민
1000000000000xxxx
1111111111111
여기서 맞추고 xxxx를 맞추는 경우가 손해인 경우가 있나?

100XXX
111

특정 n-bit 까지의 거리 계산?

 1111111 이라면
10000000 을 도달하기 까지 거리 (아래자리를 유지하면서)
즉 11111111 을 만들기까지의 거리 -> x2한담에 빼기, 1씩 더하기

1  |  111111 

11  |  11111

111  |  1111

1111  |  111

11111  |  11

111111  |  1

문제는 곱하기 하면 상위 bit까지 영향을 받긴 하네..






# ---wrong 01
우선) 최상위 bit는 무조건 1임
1xxxxxxxxxxxxxxxx
1xxxxxxxxxxx


1-1) 맞는 경우
10xxxxxxxxxxxxxxx
10xxxxxxxxxx

11xxxxxxxxxxxxxxx
11xxxxxxxxxx

1-2) 틀린 경우
10xxxxxxxxxxxxxxx
11xxxxxxxxxx
-> 1을 뺀다
-> 자리수 차이가 있으니까, 1을 더하고  shift 해서 1을 뺸다?
-> 생각해보니 중간부터 더하고 뺄 수는 없는데... 최상위 bit부터 진행은 안되겠는데?

11xxxxxxxxxxxxxxx
10xxxxxxxxxx