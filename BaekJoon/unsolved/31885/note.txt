# Feedback
C로는 너무 빡셈
 -> AVL 트리 같은거 구현하기가..
 -> iterator도 쓰고싶은데..

사실 이 문제는 정렬이 필요 없어서 MAP만으로 충분한데,
MAP 구현 나중에 해보는 것도 좋을듯 (어렵지 않아보임)

알아야 하는 내용 : for문 도는법 (그냥 재귀호출로 해도 될거같긴한데..)

K >= 1 이면,
    - start ~ end 거리 1인지 체크

K >= 2 이면, 
    - start ~ end 거리 2인지 체크 
    - startItem 에 end가 있는지 check

K >= 3 이면
    - start ~ end 거리 3인지 체크
    - startItem 에 end 거리 1 있는지 체크

K >= 4 이면
    - start ~ end  거리 4인지 체크
    - startItem 에 end 거리 2 있는지 체크
    - startItem에 endItem 있는지 체크

K >= 5 이면
    - start ~ end  거리 5인지 체크
    - startItem 에 end 거리 3 있는지 체크
    - startItem에 endItem 거리 1있는지 체크

각각 if 문으로 만들꺼기 떄문에, 이전에 찾으면 출력하고 종료,
마지막까지 못찾으면 -1 출력하는 로직


# 0001.c (포기)
(0, 0) -> (E_x, E_y)

1. 기력 1소모 x++ or y++
2. 아이템 사용, (a, b) 형태, (x+a), (y+b)
    + 아이템 소모 안하고, 기력 2 소모

기력은 0 이상 보존하려고함
초과기력은 5 이상 초과 x

아이템수 N, 초기기력 K
아이템 정보 N개
목적지 E_x, E_y


Case가 적다)
1. 아이템 사용 x

도합 5 범위 내에 있는지 체크

2. 아이템 사용 1
    -> 경우의 수 : N

아이템 기준 x, y 도합 4 범위 내에 있는지 체크


3. 아이템 사용 2
    -> 경우의 수 : N^2

아이템 수 : 2 x 10^5

출발지 기준 아이템 한번,
도착지 기준 아이템 한번(반대로), 

결과 차이가 x나 y가 1 나는 경우

결과에 대해서 x++, x--, y++, y-- 네개 만들고,
N개에 대해서 lonN으로 search

--- 
포기, C로 AVL 트리 구현해서 하는게 너무 빡세다..

C++로 MAP 같은 구조에서 하는게 맞을듯
