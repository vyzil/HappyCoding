# 0002.c
다른 구조를 생각해봐야할듯..

상위 IDX에서 자기보다 작은 값의 갯수


# 0001.c (무조건 시간초과 날 것 같아서 제출은 안함..)
이것도 세그먼트 트리느낌이 물씬?


0 - 3
  0
0 - 1   2 - 3
  0       2
0-0 1-1 2-2 3-3
 0   1   2   3


4 3 2 1

[4 3] 2 1
+ 1
3 [4 2] 1
+ 1
3 2 [4 1]
+ 1
[3 2] 1 4
+ 1
2 [3 1] 4
+1
[2 1] 3 4
+1
1 2 3 4

(Max의 index 값을 홀딩)

|-------M----|
|-------| + ((N-1) - idx) 번
-> M 부분의 index를 무효화 시킴 + 갯수를 0으로 바꿈.
-> SegTree가 범위 내에 유효한 갯수를 홀딩해야함

idx는 그냥 참조
- 0 ~ M-1 에 대해서 반복 -> 이 부분이 복잡도를 크게 만듬
- M + 1 ~ N-1 에 대해서 search (logN)

|--M---|
|--| + ((N-1) - idx) 번


이게 한번의 bubble sort라서 이걸 N번 해야하는데...?
---
최악의 경우를 고려할 때,
내가 구상한 "최댓값을 범위의 끝으로 옮긴다"는 버블소트의 시간복잡도를 따라갈 수 밖에 없음
즉, 카운트 하고 소팅해야하면 안될 것 같음

---
크게 생각해보자

1. 범위 내의 제일 큰 값의 index를 바로 찾음
2. 해당 값 이후는 무조건 swap 발생
3. 해당 값 이전에 대해서는 1번 반복

-> 한번의 버블 소트를 카운트 할 수 있음

버블 소트 결과로 바꾸는건 어떻게?
제일 큰 값을 그 이하 구간의 제일 큰 값으로 변경
=> 이렇게 구현하면 범위의 시작이 1씩 증가하네
=> 최악의 경우는 정렬되어 있는 경우..
  + 정렬되어있는지 여부도 포함한다면 어떨까 (x)
  + 5 1 6 2 7 3 8 4 9 -> 이런 경우가 있어서 복잡도는 변하지 않음
=> 최악의 경우가 아니면 (logN)^2 이긴한데

-> 버블 소트의 결과를 구현할 수 있음

---

버블소트의 결과를 구현하지 않고 전체 발생 횟수를 계산할 수 있나?

특정 idx의 값에 대해서 그 값이 몇번 swap될지 알 수 있나?

----
다시 구상, 

0 1 2 3 4 ... N
1부터 N까지 swap 여부를 판단
i 기준으로 i보다 작은 위치에 i보다 큰 값이 있으면 ㅇㅇ
즉, i 기준으로  i 보다 큰 값이 있는지 여부가 중요함

root 에서 1 ~ N 큰 idx, 
위치도 바껴야함: 범위 내의 큰 값은 갱신될때 마다 그 자리에서 교체하면됨

---

머지소트에서 뒤쪽의 idx가 증가하는 경우?
---

나보다 큰 idx중에 작은수의 갯수 -> swap 수
일단 작은 idx의 수는 이후 숫자에서 작은 수를 제치려고 할 것임.
이전수에 의해 제쳐지는 것은, 해당 수가 위의 로직을 통해 제친다고 생각하면 됨

그러면, 자신보다 큰 idx 중 작은 수의 갯수를 판별하는 문제,
segTree로 가장 큰 수를 들고 있는다고 가정하자.

자기 다음 수 부터 마지막 숫자 까지 작은 수의 갯수를 알고싶음.
노드의 숫자가 자기보다 크다?
  -> 두 자식노드 전부 탐색
노드의 숫자가 자기보다 작거나 같다? -> 전부 더함

or

작은 수의 index 값을 저장 -> 작은 수가 자신인 범위 out
큰 수의 index 값을 저장 -> 큰 수가 자신인 범위 전체 count
=> 이 두개 저장했을 때, 시간복잡도 계산을 어떻게 해야할까..
그리고, index를 가지고 있을지, 아니면 숫자로 가지고 있을지 고민..

index로 가지고있을 떄, 만약 다른쪽을 안가도 된다면 의미가 있을 것 같은데,

같은 수는 어떻게...? 
-> 일단 자신 제외하고 위서서 할꺼니까 같은수면 포함 x

노드의 숫자 기준
MAX 값이 검사하는 숫자보다 크다? -> 전부 탐색은 해야함
MAX 값이 검사하는 숫자랑 같다? -> 전부 탐색해야함
MAX 값이 검사하는 숫자보다 작다? -> 전부 count, 탐색 x  **
MIN 값이 검사하는 숫자보다 크다? -> 전부 제외, 탐색 x   **
MIN 값이 검사하는 숫자와 같다? -> 전부 제외, 탐색 x     **
MIN 값이 검사하는 숫자보다 작다? -> 전부 탐색해야함
탐색은 후순위,

-> 아까 생각해보니

작 큰 작 큰 작 큰 << 이런구조면 비효율적일거같은디
그리도 질문게시판에서 엄청 큰 테스트데이터 넣어봤는데, 틀렸음..
