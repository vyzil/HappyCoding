# 
이것도 세그먼트 트리느낌이 물씬?


0 - 3
  0
0 - 1   2 - 3
  0       2
0-0 1-1 2-2 3-3
 0   1   2   3


4 3 2 1

[4 3] 2 1
+ 1
3 [4 2] 1
+ 1
3 2 [4 1]
+ 1
[3 2] 1 4
+ 1
2 [3 1] 4
+1
[2 1] 3 4
+1
1 2 3 4

(Max의 index 값을 홀딩)

|-------M----|
|-------| + ((N-1) - idx) 번
-> M 부분의 index를 무효화 시킴 + 갯수를 0으로 바꿈.
-> SegTree가 범위 내에 유효한 갯수를 홀딩해야함

idx는 그냥 참조
- 0 ~ M-1 에 대해서 반복 -> 이 부분이 복잡도를 크게 만듬
- M + 1 ~ N-1 에 대해서 search (logN)

|--M---|
|--| + ((N-1) - idx) 번


이게 한번의 bubble sort라서 이걸 N번 해야하는데...?
---
최악의 경우를 고려할 때,
내가 구상한 "최댓값을 범위의 끝으로 옮긴다"는 버블소트의 시간복잡도를 따라갈 수 밖에 없음
즉, 카운트 하고 소팅해야하면 안될 것 같음

---
크게 생각해보자

1. 범위 내의 제일 큰 값의 index를 바로 찾음
2. 해당 값 이후는 무조건 swap 발생
3. 해당 값 이전에 대해서는 1번 반복

-> 한번의 버블 소트를 카운트 할 수 있음

버블 소트 결과로 바꾸는건 어떻게?
제일 큰 값을 그 이하 구간의 제일 큰 값으로 변경
=> 이렇게 구현하면 범위의 시작이 1씩 증가하네
=> 최악의 경우는 정렬되어 있는 경우..
  + 정렬되어있는지 여부도 포함한다면 어떨까 (x)
  + 5 1 6 2 7 3 8 4 9 -> 이런 경우가 있어서 복잡도는 변하지 않음
=> 최악의 경우가 아니면 (logN)^2 이긴한데

-> 버블 소트의 결과를 구현할 수 있음

---

버블소트의 결과를 구현하지 않고 전체 발생 횟수를 계산할 수 있나?

특정 idx의 값에 대해서 그 값이 몇번 swap될지 알 수 있나?

