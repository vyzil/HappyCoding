# 0001.c

게임에 쓰일 단어의 수 n,
박자의 수 b

n <= b
같은 단어 여러번 가능

n, b (2개)
임의의 단어 K, X (2개)
n만큼의 단어 input (n개)

1 <= n <= 2 * 10^5;
n <= b <= 10 ^ 12;
1 <= X <= 10 ^12

---

산처럼 반복된다

한 주기 최대 
-> 2*b = 2*10^12 
=> 2,000,000,000,000 이건 전체를 구해놓지도 못하네..

음..

방법 1)
- 단어 K의 갯수를 어떤 형식으로든 카운팅해서 X 도달할 때 까지
- 특정 위치에서 해당 단어의 갯수를 계산하고 가까워지도록

--
일단, 한 주기에 몇개 있는지 수학적으로 계산, 
한 주기는 2b를 의미

주기를 넘는다? -> 일단 젤 가운데 기준으로 나누기? (약간 이분탐색 가능한가?)
-> 태그보니 이분탐색이긴 하다네.. (아직 모르겠음)

--
최악의 경우는 b가 10^12일 때..
arr[단어수] => 해당 idx 까지의 누적 갯수 합을 저장

단어의 위치를 idx로 저장
최대 10^5
0 x x x x ... -1


 N : o
     o o
     o o o
2N : x x x o
     x x x o o
     x x x o o o
3N : x x x x x x o 
     x x x x x x o o
     x x x x x x o o o

누적을 쉽게 계산할 수 있으면 이분탐색이 충분히 가능할듯
누적합은 o로 구성된 삼각형 열을 우선 계산한다 -> N만큼 필요
kN까지의 누적합은 {(k-1) 까지의 합} * 한 주기에서 갯수

// 이후 푸는 방법을 적어 놓을테니 나중에 풀기.

arr[i] = 한 주기에서 i까지 등장하는 word의 갯수
한 주기에서 워드의 갯수 = arr[N-1]

큰주기 (삼각형 주기)를 계산하기 
    + 삼각형 두개 + 가운데
    + 삼각형은 정확히 N에서 끊기지 않으니 처리를 조금 해줘야함.

큰주기로 대강 X번째 워드가 등장할 수 있는 범위 추리기

추린 범위에서 가운데를 기준으로,
가운데보다 작은지, 가운데인지, 가운데보다 큰지 파악
작거나 크면 대략적인 이분탐색을 통해 KN <= X < (K+1)N 의 k를 파악 << 등호 여부는 다시 생각해봐야함
k를 찾으면 이미 N에 누적합이 있기 때문에 N번 서칭하면 됨

최악의 경우 이분탐색이 제일 critical path 인 것 같음